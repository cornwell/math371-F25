\documentclass{beamer}

\usepackage{helvet}
\usepackage{hyperref, graphicx}
\usepackage{amsthm}
\usepackage{etoolbox}

%% Define the layout of slides, numbering, and color theme
%% Also, make links in TOC appear at start of each section 
\usetheme[progressbar=frametitle, numbering=none]{metropolis}
\usecolortheme[snowy]{owl}
\setbeamertemplate{navigation symbols}{}
\AtBeginSection[ ]
{
\begin{frame}{Outline}
    \tableofcontents[currentsection]
\end{frame}
}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{11} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal - use in headings

% Custom colors
\usepackage{color}
\definecolor{TUGray}{RGB}{101,101,137}
\definecolor{TUBlack}{RGB}{0,0,10}
\definecolor{mygreen}{RGB}{45,111,63}
\definecolor{keywords}{RGB}{205,114,0}
\definecolor{comments}{RGB}{181,51,139}
\definecolor{strings}{RGB}{58,144,81}
\definecolor{numeric}{RGB}{66,110,176}
\definecolor{linos}{rgb}{0.4,0.4,0.4}
\definecolor{links}{rgb}{0,0.4,0.75}

\definecolor{bggray}{RGB}{232, 233, 235}

\setbeamercolor{alerted text}{fg=mygreen}
\setbeamercolor{normal text}{fg=TUBlack}\usebeamercolor*{normal text}

\setbeamercolor{codecol}{fg=TUGray!25!black,bg=bggray}

\hypersetup{colorlinks, linkcolor=links, urlcolor=links}

\usepackage[T1]{fontenc}
\usepackage[sfdefault,scaled=.85]{FiraSans}
\usepackage{newtxsf}

\usepackage{listings}

\newtoggle{InString}{}% Keep track of if we are within a string
\togglefalse{InString}% Assume not initally in string

\newcommand\digitstyle{\color{numeric}}
\makeatletter
\newcommand{\ProcessDigit}[1]
{%
  \ifnum\lst@mode=\lst@Pmode\relax%
   {\digitstyle #1}%
  \else
    #1%
  \fi
}
\makeatother

\lstset{literate=%
    {0}{{{\ProcessDigit{0}}}}1
    {1}{{{\ProcessDigit{1}}}}1
    {2}{{{\ProcessDigit{2}}}}1
    {3}{{{\ProcessDigit{3}}}}1
    {4}{{{\ProcessDigit{4}}}}1
    {5}{{{\ProcessDigit{5}}}}1
    {6}{{{\ProcessDigit{6}}}}1
    {7}{{{\ProcessDigit{7}}}}1
    {8}{{{\ProcessDigit{8}}}}1
    {9}{{{\ProcessDigit{9}}}}1
	{<=}{{\(\leq\)}}1
	{>=}{{\(\geq\)}}1,
	% morestring=[b]",
    % morestring=[b]',
    % morecomment=[l]//,
}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttfamily\tiny,
numbers=left,
numberstyle=\tiny\color{linos},
morekeywords={self},              % Add keywords here
keywordstyle=\tiny\color{keywords},
commentstyle=\it\tiny\color{comments},    % Custom highlighting style
stringstyle=\tiny\color{strings},
xleftmargin=18pt,
xrightmargin=4pt,
aboveskip=0pt,
belowskip=0pt,
escapeinside={(*@}{@*)},
frame=l,                         % Any extra options here
showstringspaces=false,
keepspaces=true
}}

% Python environment 
\lstnewenvironment{python}[1][]
{
	\pythonstyle
	\lstset{
	#1
	}
}
{}

% wrap the Python environment
\newenvironment{codeblock}
    {\hfill\begin{beamerboxesrounded}[lower=codecol, width=0.8\textwidth]
    \medskip

    }
    { 
    \end{beamerboxesrounded}\hfill
    }

\theoremstyle{example}
\newtheorem{question}{Question}

\newcommand{\ct}[1]{\lstinline[language=Python,basicstyle=\ttfamily\footnotesize,stringstyle=\small\color{strings}]!#1!}
\newcommand{\ttt}[1]{{\small\texttt{#1}}}
\newcommand{\lsitem}[2]{\ttt{{#1}[}\ct{#2}\ttt{]}}
\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\cl}[1]{\mathcal{#1}}
\newcommand{\comment}[1]{}

\author{Chris Cornwell}
\date{September 4, 2025}
\title{Using the NumPy Package}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{Intro to NumPy}

%%%%
\begin{frame}[fragile]
\frametitle{Getting started with NumPy}
Not built-in {--} must import NumPy into Python session. We will also want to track runtime, so we import the package \ct{time}.

\pause 
\begin{codeblock}

\begin{python}
    import numpy as np
    import time
\end{python}

\end{codeblock}

\begin{itemize}
    \item[] Create a shortcut, \ct{np}, for NumPy. This is a common convention.
\end{itemize}

\pause
\begin{itemize}
	\item Depending on how you are interacting with Python, may have to \emph{install} the \ct{numpy} package before the first use. Open a command terminal (\ct{Ctrl+`}, in VSCode on Windows) and type the appropriate command below:
\end{itemize}
\vspace*{-8pt}
\begin{itemize}
	\item[] \ct{py -m pip install numpy} (Windows)
	\item[] \ct{python}{\footnotesize\texttt{3}}\ct{ -m pip install numpy} (macOS)
    \item[] \ct{sudo pip install numpy} (Linux based)
\end{itemize}
\pause
When installing other packages, replace \ct{numpy} with the package name.

\end{frame}

\section{NumPy arrays}

%%%%
\begin{frame}[fragile]
\frametitle{Basic NumPy arrays}
The main type of object in NumPy is the \ct{ndarray} (n-dimensional array), which is constructed from a list using the command 
\begin{center}\ct{np.array(the_list)}.\end{center}

\vspace*{12pt}
\pause
If items in \ct{the_list} are of numeric type, then think of the resulting \ct{ndarray} as like a vector. Operations on NumPy arrays work like vectors in linear algebra.

\pause
Example:

\begin{codeblock}

\begin{python}
v = np.array([-1, 1, 1])
w = np.array([0.5, 0, 1.1])
# print the (vector) sum: [-0.5  1.   2.1]
print(v + w)
# prints [1.0, 0.0, 2.2]
print(2*w)
\end{python}

\end{codeblock}

\vfill
\end{frame}

%%%%
\begin{frame}[fragile]
\frametitle{More than {\ttm 1d}}
A NumPy array from a list containing numeric types makes a vector {--} also known as a 1-\emph{dimensional array} (Python language), or a \emph{tensor of order} 1 (mathematics). 

\pause
A 2-dimensional array, or tensor of order 2, is like a matrix. You construct it with \ct{np.array()} from a list of lists {--} each of the same length.

\begin{codeblock}

\begin{python}[numbers=none]
A = np.array([[1, 2, 3], [4, 5, 6]])
\end{python}

\end{codeblock}

\begin{itemize}
    \item[] Each ``inside list'' is a row. The array \ttt{A} is a $2\times 3$ matrix.
\end{itemize}

\pause
Every array in NumPy has an attribute \ct{shape}. 
\begin{itemize}
    \item Previous slide: \ct{v = np.array([-1,1,1])} has \ct{v.shape = (3,)}. 
    \item The matrix here: \ct{A.shape} is equal to \ct{(2, 3)}.
\end{itemize}
\end{frame}

%%%%
\begin{frame}[fragile]
\frametitle{Operations on arrays}

Multiplying two arrays: most recent version of Python uses the \ct{@} symbol.\footnote{In older versions, matrix multiplication is \ct{np.matmul()} and dot product is \ct{np.dot()}.} 

When the arrays are both matrices, it computes their matrix product; when one is a vector, it computes the matrix-vector product; when both are vectors, it computes the dot product.

%You can also use the function \ttt{np.dot()} for these computations. However, the \ttt{@} symbol is needed to compute products of higher order tensors.\footnote{\ttt{np.dot()} on higher tensors would compute simply the matrix product in the last two dimensions.}

\pause
For example, say that \ct{A} is the matrix ${\scriptsize \begin{bmatrix}1 & 2 & 3 \\ 4 & 5 & 6\end{bmatrix}}$ from before, \ct{v} is the vector $(-1, 1, 1)$, and let \ct{B} and \ct{u} be the matrix and vector defined in the code below.

\begin{codeblock}

\begin{python}
B = np.array([[1, 0], [1, -1], [1, 1]])
u = np.array([1, 1, 0])
(A @ B, A @ v, v @ u)
\end{python}

\end{codeblock}

\pause
\vspace*{-6pt}
Output:\ \ct{( array([[6, 1], [15, 1]]), array([4, 7]), 0 )}.

\end{frame}

%%%%
\begin{frame}
\frametitle{Indexing and slicing arrays}
Items in 1d array are accessed the same way as in a list
\vspace*{-8pt}
\begin{itemize}
    \item[] e.g., \ct{v[0]} is first item in \ct{v}, at index 0.  
\end{itemize}

\vspace*{-6pt}
For a 2d array, say the matrix \ct{A}, we can access the item in the row \ct{i} and column \ct{j} by \ct{A[i, j]}. \newline
\pause
``Slicing'' operation for arrays (also works with lists). Examples:
\begin{enumerate}
    \item Typing \ct{A[: , 0]} will give first column of the matrix.\footnote{The colon here says to take all indices in that position.}
    \pause 
    \item By typing \ct{M[:3, -3:]}, can get top-right $3\times 3$ submatrix of \ct{M}.\footnote{First position: ``get first 3 indices''; Second position: ``last 3 indices''.}
\end{enumerate}

\pause
\vspace*{-6pt}
With arrays (not lists), can even use non-consecutive indices; \textit{e.g.}, \ct{A[: ,[0,2]]} gets two columns of \ct{A} that are not adjacent. \newline 
\pause
If \ct{A} is a 2d array, its transpose is \ct{A.T}. %(providing another alternative for accessing a column).
\vfill
\end{frame}

\section{Linear algebra with NumPy}

%%%%
\begin{frame}[fragile]
\frametitle{Constructing special matrices}

Some types of matrices are used a lot; would be cumbersome to always contruct row lists ourselves (\textit{e.g.}, in $100\times100$ matrix).

\pause
\begin{itemize}
    \item[] \textbf{Zero matrix:} The command \ct{np.zeros((m, n))} constructs an $m\times n$ matrix with all entries equal to zero.
    \pause
    \item[] \textbf{Diagonal matrix:} If \ct{d} is a 1D array of length $n$, the command \ct{np.diag(d)} constructs an $n\times n$ diagonal matrix with \ct{d} as its diagonal entries.
    \pause
    \item[] \textbf{Identity matrix:} The command \ct{np.identity(n)} constructs the $n\times n$ identity matrix (and \ct{np.eye(n)} does also).
\end{itemize}

\end{frame}

%%%%
\begin{frame}
\frametitle{Using NumPy for linear algebra}
In addition to the product operations on arrays, NumPy has a library with many functions for linear algebra {--} called \ct{linalg}. 

\pause
\begin{itemize}
	\item For example, for the determinant of a square matrix \ct{M}, you type 
        \begin{center}
            np.linalg.det(M)
        \end{center}
    \pause
    \item Many other linear algebra functions in this package (see \href{https://numpy.org/doc/stable/reference/routines.linalg.html}{the docs here}). \newline 
Some are only implemented with square matrices (and perhaps only invertible ones), even though it would make sense to implement them in more general settings {--} for example, \ct{np.linalg.solve(A,b)} only solves the system of equations \ct{Ax=b} if \ct{A} is a square matrix.
\end{itemize}

\end{frame}

\subsection{Broadcasting and efficient operations}

%%%%
\begin{frame}[fragile]
\frametitle{Broadcasting, universal functions}
If you're given a 1d array and want to get the array of square roots\ldots 
\vspace*{-6pt}
\begin{itemize}
    \pause
    \item First thought: go through each entry in array, taking square root (and re-assigning as you go). In Python, this is not efficient.
\end{itemize}

\vspace*{-6pt}
\pause
Efficient way in NumPy is called \emph{broadcasting}. If \ct{v} is the \underline{array}, type 

\begin{codeblock}

\begin{python}[numbers=none]
sqrt_v = np.sqrt(v)
\end{python}

\end{codeblock}

\vspace*{-4pt}
The function \ct{np.sqrt()} takes the square root of each entry in \ct{v}; you don't need to write a \ct{for} loop.\footnote{Technically, there is a \ct{for} loop in the background, but it happens in C and works much faster.}

\pause
\vspace*{-6pt}
Functions that work on arrays this way are quite common in NumPy. They are called {\ttb ufuncs} (universal functions). \pause Other examples of ufuncs: 
    \vspace*{-6pt}
    \begin{itemize}
        \item[] \ct{np.abs()}, \ct{np.sum()}, \ct{np.maximum()}, \ct{np.minimum()}, \ct{np.exp()}, \ct{np.log()}.
    \end{itemize}
\end{frame}

%%%%
\begin{frame}
\frametitle{More on broadcasting}
Many basic operations with NumPy arrays also use broadcasting. Here are a few examples with an array \ct{v}.
\begin{enumerate}
    \item To add a number, say \ct{1.2}, to every array entry: type \ct{v+1.2}.
    \item To multiply every entry by \ct{1.2}: type \ct{1.2*v}.
    \pause
    \item To square every entry: type \ct{v**2}.
    \item To multiply \ct{v} by another array \ct{w}, entry-wise\footnote{In mathematics, this product on vectors is called the Hadamard product.}: type \ct{v*w}.
\end{enumerate}

\pause
Everything mentioned here works just as well on matrices (2d arrays), and generally on any \ttt{n}d array (higher order tensors).

\pause
\vspace*{-6pt}
\textbf{Exercise.} Use broadcasting to create a $100\times 100$ matrix with all non-diagonal entries equal to $-1$ and diagonal entries equal to $\sqrt{2} - 1$.
\end{frame}

%%%%
\begin{frame}[fragile]
\frametitle{Experiment with runtime for universal function}
To check the efficiency of broadcasting, use the \ct{time} package. Beforehand, make sure that you imported both \ct{numpy} and \ct{time} (see slide in first section).

\pause
Something simple: from a large identity matrix, we will get the exponential of the matrix (apply the function $e^x$ to every entry).

\pause
First, we use a \ct{for} loop. Run the code below in your Jupyter notebook.

\begin{codeblock}

\begin{python}
id_matrix = np.eye(1000)
exp_matrix = np.zeros((1000, 1000))
start = time.time()
for i in range(1000):
    for j in range(1000):
        exp_matrix[i,j] = np.exp(id_matrix[i,j])
end = time.time()
print(f"Seconds taken: {end-start}.")
\end{python}

\end{codeblock}

\pause
The output gives the number of seconds to run the computation. The exact time will vary based on your computer. Mine took around 0.55 seconds.
\end{frame}

%%%%
\begin{frame}[fragile]
\frametitle{Experiment with runtime for universal function}
Now, we will use broadcasting to compute the exponential of the identity matrix.

\pause
Run the following code in your Jupyter notebook.

\begin{codeblock}

\begin{python}
id_matrix = np.eye(1000)
exp_matrix = np.zeros((1000, 1000))
start = time.time()
exp_matrix = np.exp(id_matrix)
end = time.time()
print(f"Seconds taken: {end-start}.")
\end{python}

\end{codeblock}

\vspace*{12pt}
\pause
Again, the output is the number of seconds of runtime. For this approach with \ct{np.exp()}, my computer took around 0.0045 seconds. That is over 100 times faster than using the loop!
\end{frame}

\end{document}